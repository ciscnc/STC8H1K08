C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE GL08_HARDWARE
OBJECT MODULE PLACED IN .\Objects\gl08_hardware.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE Src\gl08_hardware.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inc) DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\gl08_hardware.lst) TABS(2) OBJECT(.\Objects\gl08_hardware.obj)

line level    source

   1          /*
   2           * GL08 åŒé€šé“æ§åˆ¶æ¿ç¡¬ä»¶é©±åŠ¨å®ç°
   3           * åŒ…å« GPIO, ADC, PWM å’Œ Timer ç¡¬ä»¶åˆå§‹åŒ–å’Œæ“ä½œå‡½æ•°
   4           */
   5          
   6          #include "STC8H.h"
   7          #include "gl08_hardware.h"
   8          #include "uart.h"
   9          
  10          // Global variables
  11          volatile uint8_t band_switch_1_pos = 0;  // Band switch 1 position
  12          volatile uint8_t band_switch_2_pos = 0;  // Band switch 2 position
  13          volatile uint8_t power_switch_pos = 0; // Power switch position
  14          
  15          volatile uint16_t adc_values[3] = {0, 0, 0}; // ADC sampling values
  16          
  17          //å…¨å±€å˜é‡ï¼Œå­˜æ”¾è¾“å…¥æ•è·çš„å ç©ºæ¯”å€¼
  18          volatile uint16_t pwm1_duty = 0;   //PWM1ï¼Œç«¯å£P1.0
  19          volatile uint16_t pwm2_duty = 0;   //PWM2ï¼Œç«¯å£P1.4
  20          
  21          //ç”¨äºè®¡ç®—å ç©ºæ¯”çš„ä¸´æ—¶å˜é‡
  22          static uint16_t pwm1_rise_time = 0;
  23          static uint16_t pwm1_fall_time = 0;
  24          static uint16_t pwm2_rise_time = 0;
  25          static uint16_t pwm2_fall_time = 0;
  26          
  27          //è¾…åŠ©å‡½æ•°å‰å‘å£°æ˜
  28          static void bubble_sort(uint16_t arr[], uint8_t n);  //å†’æ³¡æ’åºå‡½æ•°
  29          
  30          //å†’æ³¡æ’åºå‡½æ•°
  31          static void bubble_sort(uint16_t arr[], uint8_t n) {
  32   1          uint8_t i, j;
  33   1          uint16_t temp;
  34   1          
  35   1          for (i = 0; i < n - 1; i++) {
  36   2              for (j = 0; j < n - i - 1; j++) {
  37   3                  if (arr[j] > arr[j + 1]) {
  38   4                      // äº¤æ¢å…ƒç´ 
  39   4                      temp = arr[j];
  40   4                      arr[j] = arr[j + 1];
  41   4                      arr[j + 1] = temp;
  42   4                  }
  43   3              }
  44   2          }
  45   1      }
  46          
  47          /*========================================ç³»ç»Ÿåˆå§‹åŒ–åŠå…¶ç›¸å…³æ“ä½œå‡½æ•°=========================
             -================*/
  48          
  49          // System åˆå§‹åŒ–
  50          void system_init(void) {
  51   1        
  52   1        // å¤±èƒ½ç¡¬ä»¶çœ‹é—¨ç‹—
  53   1        WDT_CONTR = 0x00;
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 2   

  54   1      
  55   1      }
  56          
  57          // Hardware initialization
  58          void hardware_init(void) {
  59   1        gpio_init();
  60   1        adc_init();
  61   1        pwm_init();
  62   1        timer_init();
  63   1      }
  64          
  65          // GPIO åˆå§‹åŒ–
  66          void gpio_init(void) {
  67   1      
  68   1        // Set P1 port mode
  69   1        P1M1 |= (1<<0);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP1.0ç«¯å£é…ç½®ï¼Œç”¨äºæ•è·ç¬¬ä¸€è·¯PWM1çš„è¾“å…¥
  70   1        P1M0 &= ~(1<<0);
  71   1      
  72   1        P1M1 |= (1<<1);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP1.1ç«¯å£é…ç½®ï¼Œç”¨äºæ•è·ç¬¬ä¸€è·¯PWM2çš„è¾“å…¥
  73   1        P1M0 &= ~(1<<1);
  74   1      
  75   1        P1M1 |= (1<<4);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP1.4ç«¯å£é…ç½®ï¼Œç”¨äºæ•è·ç¬¬ä¸€è·¯PWM2çš„è¾“å…¥ï¼
             -Œåªæœ‰è¯¥ç«¯å£èƒ½è¿›è¡ŒåŒé€šé“æ•è·
  76   1        P1M0 &= ~(1<<4);
  77   1      
  78   1        // Set P3 port mode
  79   1        P3M1 |= (1<<2);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP3.2ç«¯å£é…ç½®ï¼ŒADCé‡‡æ ·ï¼Œé‡‡é›†åŠŸç‡æ¡£ä½
  80   1        P3M0 &= ~(1<<2);
  81   1      
  82   1        P3M1 &= ~(1<<3);  //01ï¼Œæ¨¡å¼1ï¼Œæ¨æŒ½è¾“å‡ºï¼ŒP3.3ç«¯å£é…ç½®ï¼Œç¬¬ä¸€è·¯PWMè¾“å‡º
  83   1        P3M0 |= (1<<3);
  84   1      
  85   1        P3M1 &= ~(1<<4);  //01ï¼Œæ¨¡å¼1ï¼Œæ¨æŒ½è¾“å‡ºï¼ŒP3.4ç«¯å£é…ç½®ï¼Œç¬¬äºŒè·¯PWMè¾“å‡º
  86   1        P3M0 |= (1<<4);
  87   1      
  88   1        P3M1 |= (1<<5);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP3.5ç«¯å£é…ç½®ï¼ŒADCé‡‡æ ·ï¼Œé‡‡é›†ç¬¬ä¸€è·¯æ³¢æ®µæ¡£
             -ä½
  89   1        P3M0 &= ~(1<<5);
  90   1      
  91   1        P3M1 |= (1<<6);  //10ï¼Œæ¨¡å¼2ï¼Œé«˜é˜»è¾“å…¥ï¼ŒP3.6ç«¯å£é…ç½®ï¼ŒADCé‡‡æ ·ï¼Œé‡‡é›†ç¬¬äºŒè·¯æ³¢æ®µæ¡£
             -ä½
  92   1        P3M0 &= ~(1<<6);
  93   1      
  94   1        // åˆå§‹åŒ–å®Œåå°†PWMè¾“å‡ºå¼•è„šæ‹‰ä½
  95   1        PWM_OUT1_CLR();
  96   1        PWM_OUT2_CLR();
  97   1      
  98   1      }
  99          
 100          /*========================================ADCåˆå§‹åŒ–åŠå…¶ç›¸å…³æ“ä½œå‡½æ•°============================
             -=============*/
 101          
 102          // ADC åˆå§‹åŒ–
 103          void adc_init(void) {
 104   1      
 105   1        ADCCFG = 0x2F;    //ç»“æœå³å¯¹é½ï¼Œæ—¶é’Ÿä¸º16åˆ†é¢‘ï¼šSYSclk/2/16
 106   1        ADC_CONTR = 0x80; //ä½¿èƒ½ ADC æ¨¡å—
 107   1        EADC = 0;         //å¤±èƒ½ ADC ä¸­æ–­ï¼Œé‡‡ç”¨æŸ¥è¯¢çš„æ–¹å¼
 108   1      
 109   1        delay_ms(10);    //å»¶æ—¶ç­‰å¾…ç”µæºç¨³å®š
 110   1      
 111   1        // ADC_CONTR |= 0x4A; // å¯åŠ¨ ADC10 è½¬æ¢ï¼ŒP3.2 é‡‡é›†åŠŸç‡æ¡£ä½
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 3   

 112   1        // ADC_CONTR |= 0x4D; // å¯åŠ¨ ADC13 è½¬æ¢ï¼ŒP3.5 é‡‡é›†æ³¢æ®µæ—‹é’®1
 113   1        // ADC_CONTR |= 0x4E; // å¯åŠ¨ ADC14 è½¬æ¢, P3.6 é‡‡é›†æ³¢æ®µæ—‹é’®2
 114   1      
 115   1      }
 116          
 117          // è½¬æ¢ ADC é‡‡æ ·å€¼ä¸ºç”µå‹å€¼ï¼Œå•ä½ï¼šmV
 118          uint16_t adc_to_voltage(uint16_t adc_val) {
 119   1        // Assuming 5V reference voltage, 10-bit ADC
 120   1        return (uint16_t)((uint32_t)adc_val * 5000 / ADC_RESOLUTION);
 121   1      }
 122          
 123          // å¯åŠ¨ ADC è½¬æ¢å‡½æ•°
 124          uint16_t start_adc_conversion(uint8_t adc_chanel, uint8_t convert_count){
 125   1      
 126   1        uint16_t raw_value[3];
 127   1        uint8_t i, j;
 128   1        uint32_t sum = 0;
 129   1        
 130   1        // æ£€æŸ¥é‡‡æ ·æ¬¡æ•°æ˜¯å¦è¶³å¤Ÿ
 131   1        if (convert_count < 3)
 132   1        {
 133   2          convert_count = 3; // è‡³å°‘éœ€è¦3æ¬¡é‡‡æ ·æ‰èƒ½å»æ‰ä¸¤ä¸ªæœ€å€¼
 134   2        }
 135   1        
 136   1        // åˆå§‹åŒ–æ•°ç»„
 137   1        for (i = 0; i < convert_count; i++)
 138   1        {
 139   2          raw_value[i] = 0;
 140   2        }
 141   1      
 142   1        for (i = 0; i < convert_count; i++)
 143   1        {
 144   2          ADC_CONTR &= 0xF0;                // æ¸…é™¤é€šé“é€‰æ‹©
 145   2          ADC_CONTR |= (0x0F & adc_chanel); // é€‰æ‹©é€šé“
 146   2          ADC_CONTR |= 0x40;                // å¯åŠ¨è½¬æ¢
 147   2          
 148   2      
 149   2      
 150   2          for(j=0; j<250; j++)    //
 151   2          {
 152   3            if(ADC_CONTR & 0x20)
 153   3              {
 154   4              
 155   4                if (adc_chanel == (ADC_CONTR & 0x0F))
 156   4                {
 157   5                  raw_value[i] = ((uint16_t)ADC_RES << 8) | ADC_RESL;
 158   5                }
 159   4                
 160   4                ADC_CONTR &= ~0x20; // æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½
 161   4            
 162   4              }
 163   3      
 164   3          }
 165   2       }
 166   1          
 167   1          bubble_sort(raw_value, convert_count);        // å¯¹é‡‡æ ·å€¼è¿›è¡Œæ’åº
 168   1          
 169   1          // å»æ‰æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œè®¡ç®—å‰©ä½™å€¼çš„å¹³å‡å€¼
 170   1          for (i = 1; i < convert_count - 1; i++) {    
 171   2              sum += raw_value[i];
 172   2          }
 173   1          
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 4   

 174   1          return (uint16_t)(sum / (convert_count - 2));  // è¿”å›å¹³å‡å€¼
 175   1      
 176   1      }
 177          
 178          // ADC ä¸­æ–­æœåŠ¡å‡½æ•°(è¿™é‡Œæœªä½¿ç”¨ä¸­æ–­çš„æ–¹å¼ï¼Œè€Œæ˜¯ä½¿ç”¨æŸ¥è¯¢çš„æ–¹å¼)
 179          void adc_Isr(void) interrupt 5 
 180          {
 181   1        // 
 182   1      }
 183          
 184          /*========================================PWMåˆå§‹åŒ–åŠå…¶ç›¸å…³æ“ä½œå‡½æ•°============================
             -=============*/
 185          
 186          // PWM åˆå§‹åŒ–
 187          void pwm_init(void) {
 188   1      
 189   1        pwmb_oc_init(); //PWMBè¾“å‡ºæ¨¡å¼åˆå§‹åŒ–
 190   1      
 191   1        pwma_ic_init(); //PWMAè¾“å…¥æ•è·æ¨¡å¼åˆå§‹åŒ–
 192   1      
 193   1      }
 194          
 195          // PWMæ¯”è¾ƒè¾“å‡ºåˆå§‹åŒ–
 196          void pwmb_oc_init(void){
 197   1      
 198   1        PWMB_PSCR = PWMB_PSC;  //24åˆ†é¢‘
 199   1      
 200   1        PWMB_PS = 0x50;  //bit7~bit4 = 0101ï¼Œé«˜çº§ PWM é€šé“ 8 è¾“å‡ºè„šé€‰æ‹©P3.4ï¼Œbit7 bit6 = 01, é«˜çº§ P
             -WM é€šé“ 7 è¾“å‡ºè„šé€‰æ‹©P3.3ï¼Œbit5 bit4 = 01
 201   1      
 202   1        PWMB_CCER2 = 0x00;  //å†™ CCMRx å‰å¿…é¡»å…ˆæ¸…é›¶ CCxE å…³é—­é€šé“
 203   1        PWMB_CCMR3 = 0x60;  //é…ç½®PWM7ä¸ºPWMæ¨¡å¼1
 204   1        PWMB_CCMR4 = 0x60;  //é…ç½®PWM8ä¸ºPWMæ¨¡å¼1
 205   1      
 206   1        PWMB_CCR7 = PWM7_DUTY;  //PWM7åˆå§‹åŒ–å ç©ºæ¯”
 207   1        PWMB_CCR8 = PWM8_DUTY;  //PWM8åˆå§‹åŒ–å ç©ºæ¯”
 208   1      
 209   1        PWMB_ARR = PWMB_PERIOD-1;  //PWMAå‘¨æœŸ
 210   1      
 211   1        PWMB_CCER2 = 0x11;  //ä½¿èƒ½PWM7ã€PWM8é€šé“ï¼Œé«˜ç”µå¹³æœ‰æ•ˆ
 212   1      
 213   1        PWMB_ENO = 0x50;    //ä½¿èƒ½PWM7ã€PWM8ç«¯å£è¾“å‡º
 214   1        PWMB_BKR = 0x80;    //ä½¿èƒ½ä¸»è¾“å‡º
 215   1      
 216   1        PWMB_CR1 = 0x01; //ä½¿èƒ½è®¡æ•°å™¨
 217   1      
 218   1      }
 219          
 220          // PWMè¾“å…¥æ•è·åˆå§‹åŒ–
 221          void pwma_ic_init(void){
 222   1      
 223   1        PWMA_PSCR = PWMA_PSC;  //24åˆ†é¢‘ï¼Œè®¡æ•°ä¸€ä¸ª TICK ä¸º 1us
 224   1        PWMA_ARR = 0xFFFF;     // æœ€å¤§è®¡æ•°å‘¨æœŸ
 225   1      
 226   1        PWMA_PS = 0x00;       //b5b4 = 00:PWM1Pæ˜ å°„åˆ°P1.0ï¼›b1b0 = 00:PWM3Pæ˜ å°„åˆ°P1.4
 227   1      
 228   1        PWMA_CCER1 = 0x00;   //bit0å…³é—­CC1,bit4å…³é—­CC2
 229   1        PWMA_CCMR1 = 0x01;   //IC1ä¸ºè¾“å…¥æ¨¡å¼ï¼Œä¸”æ˜ å°„åˆ°T11TP1ä¸Š
 230   1        PWMA_CCMR1 &= 0x0F;  // æ»¤æ³¢è®¾ä¸º8ä¸ªæ—¶é’Ÿ
 231   1        PWMA_CCMR1 |= 0x30;  // 
 232   1        PWMA_CCMR2 = 0x02;   //IC2ä¸ºè¾“å…¥æ¨¡å¼ï¼Œä¸”æ˜ å°„åˆ°T11TP2ä¸Š
 233   1        PWMA_CCMR2 &= 0x0F;  // æ»¤æ³¢è®¾ä¸º8ä¸ªæ—¶é’Ÿ
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 5   

 234   1        PWMA_CCMR2 |= 0x30; 
 235   1      //  PWMA_CCER1 = 0x11;   //ä½¿èƒ½CC1,CC2ä¸Šçš„è¾“å…¥æ•è·åŠŸèƒ½ï¼Œé€šè¿‡å¤–éƒ¨å‡½æ•°å†å¼€å¯
 236   1        PWMA_CCER1 |= 0x00;  //è®¾ç½®æ•è·ææ€§ä¸ºCC1çš„ä¸Šå‡æ²¿
 237   1        PWMA_CCER1 |= 0x20;  //è®¾ç½®æ•è·ææ€§ä¸ºCC2çš„ä¸‹é™æ²¿
 238   1        // PWMA_SMCR = 0X54; //TI1FP1(CC1æ˜ å°„åœ¨TI1FP1)ä»æ¨¡å¼å¤ä½ï¼šä¸Šå‡æ²¿å¤ä½è®¡æ•°å™¨ï¼Œå³CC1é€šé
             -“æ•è·åˆ°ä¸Šå‡æ²¿ä¼šå¤ä½è®¡æ•°å™¨
 239   1      
 240   1        PWMA_CCER2 = 0x00;   //bit0å…³é—­CC3,bit4å…³é—­CC4
 241   1        PWMA_CCMR3 = 0x01;   //IC3ä¸ºè¾“å…¥æ¨¡å¼ï¼Œä¸”æ˜ å°„åˆ°TI3TP3ä¸Š
 242   1        PWMA_CCMR3 &= 0x0F;  // æ»¤æ³¢è®¾ä¸º8ä¸ªæ—¶é’Ÿ
 243   1        PWMA_CCMR3 |= 0x30;  // 
 244   1        PWMA_CCMR4 = 0x02;   //IC4ä¸ºè¾“å…¥æ¨¡å¼ï¼Œä¸”æ˜ å°„åˆ°TI3TP4ä¸Š
 245   1        PWMA_CCMR4 &= 0x0F;  // æ»¤æ³¢è®¾ä¸º8ä¸ªæ—¶é’Ÿ
 246   1        PWMA_CCMR4 |= 0x30;  // 
 247   1      //  PWMA_CCER2 = 0x11;   //ä½¿èƒ½CC3,CC4ä¸Šçš„è¾“å…¥æ•è·åŠŸèƒ½ï¼Œé€šè¿‡å¤–éƒ¨å‡½æ•°å†å¼€å¯
 248   1        PWMA_CCER2 |= 0x00;  //è®¾ç½®æ•è·ææ€§ä¸ºCC3çš„ä¸Šå‡æ²¿
 249   1        PWMA_CCER2 |= 0x20;  //è®¾ç½®æ•è·ææ€§ä¸ºCC4çš„ä¸‹é™æ²¿
 250   1      
 251   1      //  PWMA_IER = 0x1E; //ä½¿èƒ½CC1,CC2,CC3,CC4æ•è·ä¸­æ–­ï¼Œé€šè¿‡å¤–éƒ¨å‡½æ•°å†å¼€å¯
 252   1      
 253   1        PWMA_CR1 = 0x01; //ä½¿èƒ½è®¡æ•°å™¨
 254   1      
 255   1      }
 256          
 257          // åŠ¨æ€è°ƒèŠ‚PWMå ç©ºæ¯”
 258          void set_pwm_duty(uint8_t channel, uint16_t duty)
 259          {
 260   1        if (duty > PWM_FREQUENCY)
 261   1        {
 262   2          duty = PWM_FREQUENCY;
 263   2        }
 264   1      
 265   1        switch (channel)
 266   1        {
 267   2        case D1:
 268   2          PWMB_CCR7 = duty;  // duty èŒƒå›´ 0 ~ PWMB_ARR
 269   2          break;
 270   2      
 271   2        case D2:
 272   2          PWMB_CCR8 = duty;  // duty èŒƒå›´ 0 ~ PWMB_ARR
 273   2          break;
 274   2        
 275   2        default:
 276   2      
 277   2          break;
 278   2        }
 279   1      }
 280          
 281          // åŠ¨æ€è·å–è¾“å…¥æ•è·åˆ°çš„å ç©ºæ¯”å€¼
 282          uint16_t get_pwm_ic_duty(uint8_t channel){
 283   1      
 284   1        if (channel == PWM1)
 285   1        {
 286   2          return pwm1_duty;
 287   2        }
 288   1      
 289   1          return pwm2_duty;
 290   1      
 291   1      }
 292          
 293          // å¼€å§‹ CC1 å’Œ CC2 åŒé€šé“æ•è·ï¼ŒåŒæ—¶æ•è·P1.0å¼•è„š(PWM1)
 294          void pwma_ic1_start(void)
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 6   

 295          {
 296   1        PWMA_CCER1 |= 0x11; // ä½¿èƒ½CC1,CC2è¾“å…¥æ•è·
 297   1        PWMA_IER |= 0x06;   // ä½¿èƒ½æ•è·ä¸­æ–­
 298   1        PWMA_CR1 |= 0x01;  // ç¡®ä¿è®¡æ•°å™¨è¿è¡Œ
 299   1      }
 300          
 301          // å¼€å§‹ CC3 å’Œ CC4 åŒé€šé“æ•è·ï¼ŒåŒæ—¶æ•è·P1.4å¼•è„š(PWM2)
 302          void pwma_ic2_start(void)
 303          {
 304   1        PWMA_CCER2 |= 0x11; // ä½¿èƒ½CC3,CC4è¾“å…¥æ•è·
 305   1        PWMA_IER |= 0x18;   // ä½¿èƒ½æ•è·ä¸­æ–­
 306   1        PWMA_CR1 |= 0x01;  // ç¡®ä¿è®¡æ•°å™¨è¿è¡Œ
 307   1      }
 308          
 309          // åœæ­¢æ•è· PWM1
 310          void pwma_ic1_stop(void)
 311          {
 312   1        PWMA_CCER1 &= ~0x11; // å…³é—­CC1,CC2è¾“å…¥æ•è·
 313   1        PWMA_IER &= ~0x06;   // å…³é—­æ•è·ä¸­æ–­
 314   1                           // æ³¨æ„ï¼šè¿™é‡Œä¸åœæ­¢è®¡æ•°å™¨ï¼Œå› ä¸ºå¯èƒ½å…¶ä»–åŠŸèƒ½è¿˜åœ¨ä½¿ç”¨
 315   1      }
 316          
 317          // åœæ­¢æ•è· PWM2
 318          void pwma_ic2_stop(void)
 319          {
 320   1        
 321   1        PWMA_CCER2 &= ~0x11; // å…³é—­CC3,CC4è¾“å…¥æ•è·
 322   1        PWMA_IER &= ~0x18;   // å…³é—­æ•è·ä¸­æ–­
 323   1                           // æ³¨æ„ï¼šè¿™é‡Œä¸åœæ­¢è®¡æ•°å™¨ï¼Œå› ä¸ºå¯èƒ½å…¶ä»–åŠŸèƒ½è¿˜åœ¨ä½¿ç”¨
 324   1      }
 325          
 326          // PWM è¾“å…¥æ•è·ä¸­æ–­æœåŠ¡å‡½æ•°
 327          void pwm_ic_isr(void) interrupt 26  
 328          {
 329   1      
 330   1        
 331   1          // æ•è·PWM1
 332   1          if (PWMA_SR1 & 0x02)  // CC1ä¸Šå‡æ²¿æ•è·
 333   1          {
 334   2              pwm1_rise_time = PWMA_CCR1;
 335   2              PWMA_SR1 &= ~0x02;   // æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½
 336   2          }
 337   1          if (PWMA_SR1 & 0x04)  // CC2ä¸‹é™æ²¿æ•è·
 338   1          {
 339   2              pwm1_fall_time = PWMA_CCR2;
 340   2              DISABLE_TIMER0();
 341   2              
 342   2              // è®¡ç®—é«˜ç”µå¹³æ—¶é—´ï¼Œå‘¨æœŸä¸å˜ï¼Œä¸”PWMåˆ†é¢‘ç³»æ•°ä¸€æ ·ï¼Œé«˜ç”µå¹³æ—¶é—´å³ä¸ºå ç©ºæ¯
             -”
 343   2              if (pwm1_fall_time >= pwm1_rise_time) {
 344   3                  pwm1_duty = pwm1_fall_time - pwm1_rise_time;
 345   3              } else {
 346   3                  pwm1_duty = (0xFFFF - pwm1_rise_time) + pwm1_fall_time;  //è€ƒè™‘è®¡æ•°å™¨æº¢å‡º
 347   3              }
 348   2              
 349   2              PWMA_SR1 &= ~0x04;   // æ¸…æ ‡å¿—
 350   2          }
 351   1      
 352   1          // æ•è·PWM2
 353   1          if (PWMA_SR1 & 0x08)   // CC3ä¸Šå‡æ²¿æ•è·
 354   1          {
 355   2              pwm2_rise_time = PWMA_CCR3;
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 7   

 356   2              PWMA_SR1 &= ~0x08;
 357   2          }
 358   1          if (PWMA_SR1 & 0x10)  // CC4ä¸‹é™æ²¿æ•è·
 359   1          {
 360   2              pwm2_fall_time = PWMA_CCR4;
 361   2              DISABLE_TIMER1();
 362   2              
 363   2              // è®¡ç®—é«˜ç”µå¹³æ—¶é—´ï¼Œå‘¨æœŸä¸å˜ï¼Œä¸”PWMåˆ†é¢‘ç³»æ•°ä¸€æ ·ï¼Œé«˜ç”µå¹³æ—¶é—´å³ä¸ºå ç©ºæ¯
             -”
 364   2              if (pwm2_fall_time >= pwm2_rise_time) {
 365   3                  pwm2_duty = pwm2_fall_time - pwm2_rise_time;
 366   3              } else {
 367   3                  pwm2_duty = (0xFFFF - pwm2_rise_time) + pwm2_fall_time;  //è€ƒè™‘è®¡æ•°å™¨æº¢å‡º
 368   3              }
 369   2      
 370   2              PWMA_SR1 &= ~0x10;        
 371   2          }
 372   1      }
 373          
 374          /*========================================Timeråˆå§‹åŒ–åŠå…¶ç›¸å…³æ“ä½œå‡½æ•°==========================
             -===============*/
 375          
 376          // Timer åˆå§‹åŒ–
 377          void timer_init(void) {
 378   1        
 379   1        // é…ç½® Timer0 and Timer1 ä¸º 2ms è§¦å‘æº¢å‡ºä¸­æ–­ï¼Œç”¨äºæ£€æµ‹ PWM 0% å’Œ 100% çš„è¾“å…¥æƒ…å†µ
 380   1        TMOD = 0x00; // Timer0 and Timer1 both works in mode 0  
 381   1        TH0 = TIMER0_RELOAD_H;
 382   1        TL0 = TIMER0_RELOAD_L;
 383   1      
 384   1        // Enable Timer0 interrupt
 385   1        ET0 = 1;
 386   1      
 387   1        // Start Timer0
 388   1        TR0 = 1;
 389   1        
 390   1        TL1 = TIMER1_RELOAD_H;
 391   1        TH1 = TIMER1_RELOAD_L; 
 392   1      
 393   1        // Enable Timer1 interrupt
 394   1        ET1 = 1; 
 395   1        
 396   1        // Start Timer1
 397   1        TR1 = 1; 
 398   1        
 399   1      }
 400          
 401          // Timer0 ä¸­æ–­æœåŠ¡å‡½æ•°
 402          void timer0_isr(void) interrupt 1
 403          {
 404   1          TF0 = 0;  // æ¸…é™¤å®šæ—¶å™¨0æº¢å‡ºä¸­æ–­æ ‡å¿—
 405   1          
 406   1          // åœ¨ä¸­æ–­ä¸­å…³é—­å®šæ—¶å™¨0
 407   1          DISABLE_TIMER0(); 
 408   1        
 409   1          if(READ_PWM1_INPUT()){  //æ£€æµ‹PWM1è¾“å…¥å¼•è„šP1.0ç”µå¹³å€¼
 410   2              pwm1_duty = 1000;
 411   2          } else {
 412   2              pwm1_duty = 0;
 413   2          }
 414   1      
 415   1      }
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 8   

 416          
 417          // Timer1 ä¸­æ–­æœåŠ¡å‡½æ•°
 418          void Timer1_ISR(void) interrupt 3 
 419          {
 420   1          TF1 = 0;  // æ¸…é™¤å®šæ—¶å™¨1æº¢å‡ºä¸­æ–­æ ‡å¿—
 421   1          
 422   1          // åœ¨ä¸­æ–­ä¸­å…³é—­å®šæ—¶å™¨1
 423   1          DISABLE_TIMER1(); 
 424   1          
 425   1          if(READ_PWM2_INPUT()){  //æ£€æµ‹PWM2è¾“å…¥å¼•è„šP1.4ç”µå¹³å€¼
 426   2              pwm2_duty = 1000;
 427   2          } else {
 428   2              pwm2_duty = 0;
 429   2          }
 430   1      }
 431          
 432          /*========================================æ—‹é’®æ¡£ä½ç›¸å…³æ“ä½œå‡½æ•°==================================
             -=======*/
 433          
 434          // è¯»å–æ³¢æ®µæ—‹é’®æ¡£ä½
 435          uint8_t read_band_switch(uint8_t band_switch) {
 436   1      
 437   1        uint8_t switch_state = 0;
 438   1        uint16_t adc_result = 0;
 439   1        uint16_t voltage_result = 0;  //è½¬æ¢ä¸ºç”µå‹çš„ç»“æœå•ä½ä¸ºï¼šmv
 440   1        adc_result = adc_values[band_switch];    // è¯»å–å­˜æ”¾çš„ ADC é‡‡æ ·å€¼
 441   1        voltage_result = adc_to_voltage(adc_result);  // å°†é‡‡æ ·å€¼è½¬æ¢ä¸ºç”µå‹å€¼ï¼ˆmvï¼‰
 442   1      
 443   1        // æ ¹æ®ç”µå‹å€¼åˆ¤æ–­æ¡£ä½
 444   1        if (voltage_result <= (BAND_SWITCH_EXT_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 445   1        {
 446   2          switch_state = BAND_EXT;
 447   2        }
 448   1        else if (voltage_result >= (BAND_SWITCH_1_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 449   1                  voltage_result <= (BAND_SWITCH_1_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 450   1        {
 451   2          switch_state = BAND_0;
 452   2        }
 453   1        else if (voltage_result >= (BAND_SWITCH_2_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 454   1                  voltage_result <= (BAND_SWITCH_2_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 455   1        {
 456   2          switch_state = BAND_25;
 457   2        }
 458   1        else if (voltage_result >= (BAND_SWITCH_3_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 459   1                  voltage_result <= (BAND_SWITCH_3_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 460   1        {
 461   2          switch_state = BAND_50;
 462   2        }
 463   1        else if (voltage_result >= (BAND_SWITCH_4_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 464   1                  voltage_result <= (BAND_SWITCH_4_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 465   1        {
 466   2          switch_state = BAND_75;
 467   2        }
 468   1        else if (voltage_result >= (BAND_SWITCH_5_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 469   1                  voltage_result <= BAND_SWITCH_5_VOLGATE)
 470   1        {
 471   2          switch_state = BAND_100;
 472   2        }
 473   1        
 474   1        if(band_switch == 0){
 475   2          
 476   2          uart_sendstr("band1 voltage(mv):");
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 9   

 477   2          uart_uint16(voltage_result);
 478   2          uart_sentEnter();
 479   2        
 480   2      
 481   2        }
 482   1        else{
 483   2          uart_sendstr("band2 voltage(mv):");
 484   2          uart_uint16(voltage_result);
 485   2          uart_sentEnter();
 486   2          
 487   2        }
 488   1      
 489   1        return switch_state;
 490   1      }
 491          
 492          // è¯»å–åŠŸç‡æ—‹é’®æ¡£ä½
 493          uint8_t read_power_switch(void) {
 494   1      
 495   1        uint8_t switch_state = 0;
 496   1        uint16_t adc_result = 0;
 497   1        uint16_t voltage_result = 0;  //è½¬æ¢ä¸ºç”µå‹çš„ç»“æœå•ä½ä¸ºï¼šmv
 498   1        adc_result = adc_values[2];   // è¯»å–å­˜æ”¾çš„ ADC é‡‡æ ·å€¼
 499   1        voltage_result = adc_to_voltage(adc_result);   // å°†é‡‡æ ·å€¼è½¬æ¢ä¸ºç”µå‹å€¼ï¼ˆmvï¼‰
 500   1      
 501   1        // æ ¹æ®ç”µå‹å€¼åˆ¤æ–­æ¡£ä½
 502   1        if (voltage_result <= (POWER_SWITCH_1_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 503   1        {
 504   2          switch_state = POWER_LIMIT_67;
 505   2        }
 506   1        else if (voltage_result >= (POWER_SWITCH_2_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 507   1                voltage_result <= (POWER_SWITCH_2_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE))
 508   1        {
 509   2          switch_state = POWER_LIMIT_83;
 510   2        }
 511   1        else if (voltage_result >= (POWER_SWITCH_3_VOLGATE-OLLOW_VOLGATE_DIFFERENCE_VALUE) && 
 512   1                voltage_result <= POWER_SWITCH_3_VOLGATE+OLLOW_VOLGATE_DIFFERENCE_VALUE)
 513   1        {
 514   2          switch_state = POWER_LIMIT_100;
 515   2        }
 516   1        
 517   1        uart_sendstr("power voltage(mv):");
 518   1        uart_uint16(voltage_result);
 519   1        uart_sentEnter();
 520   1        
 521   1        uart_sentEnter();
 522   1      
 523   1        return switch_state;
 524   1      }
 525          
 526          // æ‰«æå„ä¸ªæ—‹é’®çš„æ¡£ä½
 527          void scan_switches(void) {
 528   1        // Read band switch position
 529   1        band_switch_1_pos = read_band_switch(0);  // æ‰«ææ³¢æ®µæ—‹é’®1ï¼ˆK1ï¼‰çš„æ¡£ä½
 530   1        band_switch_2_pos = read_band_switch(1);  // æ‰«ææ³¢æ®µæ—‹é’®2ï¼ˆK2ï¼‰çš„æ¡£ä½
 531   1      
 532   1        // Read power switch position
 533   1        power_switch_pos = read_power_switch();   // æ‰«æåŠŸç‡æ—‹é’®çš„æ¡£ä½
 534   1        
 535   1        uart_sendstr("band1 switch pos:");
 536   1        uart_uint8(band_switch_1_pos);
 537   1        uart_sentEnter();
 538   1        
C51 COMPILER V9.60.7.0   GL08_HARDWARE                                                     11/11/2025 14:35:51 PAGE 10  

 539   1        uart_sendstr("band2 switch pos:");
 540   1        uart_uint8(band_switch_2_pos);
 541   1        uart_sentEnter();
 542   1        
 543   1        uart_sendstr("power switch pos:");
 544   1        uart_uint8(power_switch_pos);
 545   1        uart_sentEnter();
 546   1        
 547   1        uart_sentEnter();
 548   1        
 549   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1478    ----
   CONSTANT SIZE    =    111    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
