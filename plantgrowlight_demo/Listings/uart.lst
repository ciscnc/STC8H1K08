C51 COMPILER V9.60.7.0   UART                                                              11/11/2025 14:35:51 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE Src\uart.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inc) DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          /*
   2           * STC8H1K08 串口通信功能实现
   3           * 使用中断的方式进行发送和接收；包含8位，16位，字符串发送函数
   4           */
   5          
   6          #include "STC8H.h"
   7          #include "type_def.h"
   8          #include "uart.h"
   9          
  10          #if UART_PRINT
  11          
  12          // 接收缓冲区与指针
  13          #define UART_BUF_SIZE 16
  14          uint8_t uart_buf[UART_BUF_SIZE];
  15          uint8_t rptr = 0;    // 接收写入指针
  16          uint8_t wptr = 0;    // 接收读取指针（若需FIFO可扩展）
  17          volatile uint8_t busy = 0;    // 发送忙标志
  18          
  19          
  20          // UART 初始化
  21          void uart_init(void)
  22          {
  23   1        
  24   1          // 配置串口模式：模式1，可变波特率8位数据，允许接收
  25   1          SCON = 0x50;      // 0x50 = 0101 0000，REN=1（允许接收），SM1=1（模式1）
  26   1        
  27   1          AUXR &= ~(1<<4);  // Timer2 stop
  28   1          AUXR |= 0x01;     // 使用 Timer2 作为波特率发生器
  29   1          AUXR &= ~(1<<3);  // Timer2 set As Timer
  30   1          AUXR |=  (1<<2);  // Timer2 设置为 1T 模式
  31   1          T2L = BRT;        // 波特率发生器数，Timer2
  32   1          T2H = BRT >> 8; 
  33   1          IE2  &= ~(1<<2);  //禁止 Timer2 中断
  34   1          AUXR |=  (1<<4);  //使能 Timer2
  35   1      
  36   1          ES = 1;     //使能串口1中断
  37   1      
  38   1      }
  39          
  40          // UART 中断服务函数
  41          void uart_isr(void) interrupt 4
  42          {
  43   1          if (TI) {  // 发送中断（数据发送完成）
  44   2              TI = 0;
  45   2              busy = 0;  // 发送完成，释放忙标志
  46   2          }
  47   1          if (RI) {  // 接收中断（数据接收完成）
  48   2              RI = 0;
  49   2              uart_buf[rptr++] = SBUF;  // 数据存入缓冲区
  50   2              rptr %= UART_BUF_SIZE;   // 循环缓冲区，防止溢出
  51   2          }
  52   1      }
  53          
  54          
C51 COMPILER V9.60.7.0   UART                                                              11/11/2025 14:35:51 PAGE 2   

  55          // 单字节发送（中断方式，非阻塞）
  56          void uart_send(uint8_t dat)
  57          {
  58   1          while (busy);  // 等待上一次发送完成
  59   1          busy = 1;      // 标记为忙
  60   1          SBUF = dat;    // 写入数据到发送缓冲
  61   1      }
  62          
  63          // 8位无符号数发送（目前只能打印0~9）
  64          void uart_uint8(uint8_t dat)
  65          {
  66   1          dat += '0';
  67   1          while (busy);  // 等待上一次发送完成
  68   1          busy = 1;      // 标记为忙
  69   1          SBUF = dat;    // 写入数据到发送缓冲
  70   1      }
  71          
  72          // 16位无符号数发送
  73          void uart_uint16(uint16_t dat)
  74          {
  75   1        uint16_t temp = 10000;
  76   1        uint8_t byte;
  77   1        do{
  78   2          byte = dat / temp;
  79   2          byte += '0';
  80   2          uart_send(byte);
  81   2          dat %= temp;
  82   2          temp /= 10;
  83   2        }while(temp);
  84   1      }
  85          
  86          // 换行符发送
  87          void uart_sentEnter(void)
  88          {
  89   1        uart_send('\r');
  90   1        uart_send('\n');
  91   1      }
  92          
  93          // 字符串发送（循环调用单字节发送）
  94          void uart_sendstr(const uint8_t *str)
  95          {
  96   1          while (*str) {
  97   2              uart_send(*str++);
  98   2          }
  99   1      }
 100          
 101          // 查询方式：读取接收缓冲区（非中断场景可用）
 102          uint8_t uart_recv(void)
 103          {
 104   1          uint8_t dat = 0;
 105   1          if (rptr != wptr) {  // 缓冲区有数据
 106   2              dat = uart_buf[wptr++];
 107   2              wptr %= UART_BUF_SIZE;
 108   2          }
 109   1          return dat;
 110   1      }
 111          
 112          // 中断方式：判断缓冲区是否有数据（供上层逻辑轮询）
 113          uint8_t uarthasdata(void)
 114          {
 115   1          return (rptr != wptr);
 116   1      }
C51 COMPILER V9.60.7.0   UART                                                              11/11/2025 14:35:51 PAGE 3   

 117          
 118          
 119          #else  //禁用串口打印时，空实现
              
              #define NOT_SUPPORTED 0
              
              void communication_init(void) {}
              void uart_init(void) {}
              void uart_isr(void) interrupt 4 {}
              void uart_send(uint8_t dat) {}
              void uart_uint8(uint8_t dat) {}
              void uart_uint16(uint16_t dat) {}
              void uart_sentEnter(void) {}
              void uart_sendstr(const uint8_t *str){}
              uint8_t uart_recv(void) 
              {
                return NOT_SUPPORTED;
              }
              uint8_t uarthasdata(void) 
              {
                return NOT_SUPPORTED;
              }
                
              #endif   //UART_PRINT


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    247    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
