C51 COMPILER V9.60.7.0   GL08_COMMUNICATION                                                11/10/2025 16:06:44 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE GL08_COMMUNICATION
OBJECT MODULE PLACED IN .\Objects\gl08_communication.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE Src\gl08_communication.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inc) DEBUG OBJEC
                    -TEXTEND PRINT(.\Listings\gl08_communication.lst) TABS(2) OBJECT(.\Objects\gl08_communication.obj)

line level    source

   1          /*
   2           * GL08 Dual Channel Control Board Communication Protocol Implementation
   3           * Contains RJ12 network communication and cascade control functions
   4           */
   5          
   6          #include "gl08_communication.h"
   7          #include "STC8H.h"
   8          #include "type_def.h"
   9          
  10          #define UART_EABLE 1
  11          
  12          #if UART_EABLE
  13          
  14          // 接收缓冲区与指针
  15          #define UART_BUF_SIZE 16
  16          uint8_t uart_buf[UART_BUF_SIZE];
  17          uint8_t rptr = 0;    // 接收写入指针
  18          uint8_t wptr = 0;    // 接收读取指针（若需FIFO可扩展）
  19          volatile uint8_t busy = 0;    // 发送忙标志
  20          
  21          // Communication initialization
  22          void communication_init(void)
  23          {
  24   1          uart_init();
  25   1      }
  26          
  27          // UART initialization
  28          void uart_init(void)
  29          {
  30   1        
  31   1          // 1. 配置串口模式：模式1，可变波特率8位数据，允许接收
  32   1          SCON = 0x50; // 0x50 = 0101 0000，REN=1（允许接收），SM1=1（模式1）
  33   1        
  34   1          AUXR &= ~(1<<4);  //Timer stop
  35   1          AUXR |= 0x01;   //S1 BRT Use Timer2;
  36   1          AUXR &= ~(1<<3);  //Timer2 set As Timer
  37   1          AUXR |=  (1<<2);  //Timer2 set as 1T mode
  38   1          T2L = BRT;       // 波特率发生器数，Timer2
  39   1          T2H = BRT >> 8; 
  40   1          IE2  &= ~(1<<2);  //禁止中断
  41   1          AUXR |=  (1<<4);  //Timer run enable
  42   1      
  43   1          ES = 1;     //使能串口1中断
  44   1      
  45   1      }
  46          
  47          // UART interrupt service program
  48          void uart_isr(void) interrupt 4
  49          {
  50   1          if (TI) {  // 发送中断（数据发送完成）
  51   2              TI = 0;
  52   2              busy = 0;  // 发送完成，释放忙标志
  53   2          }
  54   1          if (RI) {  // 接收中断（数据接收完成）
C51 COMPILER V9.60.7.0   GL08_COMMUNICATION                                                11/10/2025 16:06:44 PAGE 2   

  55   2              RI = 0;
  56   2              uart_buf[rptr++] = SBUF;  // 数据存入缓冲区
  57   2              rptr %= UART_BUF_SIZE;   // 循环缓冲区，防止溢出
  58   2          }
  59   1      }
  60          
  61          
  62          // 单字节发送（中断方式，非阻塞）
  63          void uart_send(uint8_t dat)
  64          {
  65   1          while (busy);  // 等待上一次发送完成
  66   1          busy = 1;      // 标记为忙
  67   1          SBUF = dat;    // 写入数据到发送缓冲
  68   1      }
  69          
  70          // 单字节发送（中断方式，非阻塞）
  71          void uart_uint8_t(uint8_t dat)
  72          {
  73   1          dat += '0';
  74   1          while (busy);  // 等待上一次发送完成
  75   1          busy = 1;      // 标记为忙
  76   1          SBUF = dat;    // 写入数据到发送缓冲
  77   1      }
  78          
  79          // 无符号16位发送（中断方式，非阻塞）
  80          void uart_uint16(uint16_t dat)
  81          {
  82   1        uint16_t temp = 10000;
  83   1        uint8_t byte;
  84   1        do{
  85   2          byte = dat / temp;
  86   2          byte += '0';
  87   2          uart_send(byte);
  88   2          dat %= temp;
  89   2          temp /= 10;
  90   2        }while(temp);
  91   1      }
  92          
  93          // 换行符发送（中断方式，非阻塞）
  94          void uart_sentEnter(void)
  95          {
  96   1        uart_send('\r');
  97   1        uart_send('\n');
  98   1      }
  99          
 100          // 字符串发送（循环调用单字节发送）
 101          void uart_sendstr(const uint8_t *str)
 102          {
 103   1          while (*str) {
 104   2              uart_send(*str++);
 105   2          }
 106   1      }
 107          
 108          // 查询方式：读取接收缓冲区（非中断场景可用）
 109          uint8_t uart_recv(void)
 110          {
 111   1          uint8_t dat = 0;
 112   1          if (rptr != wptr) {  // 缓冲区有数据
 113   2              dat = uart_buf[wptr++];
 114   2              wptr %= UART_BUF_SIZE;
 115   2          }
 116   1          return dat;
C51 COMPILER V9.60.7.0   GL08_COMMUNICATION                                                11/10/2025 16:06:44 PAGE 3   

 117   1      }
 118          
 119          // 中断方式：判断缓冲区是否有数据（供上层逻辑轮询）
 120          uint8_t uarthasdata(void)
 121          {
 122   1          return (rptr != wptr);
 123   1      }
 124          
 125          
 126          #else  //禁用串口打印时，空实现
              
              #define NOT_SUPPORTED 0
              
              void communication_init(void) {}
              void uart_init(void) {}
              void uart_isr(void) interrupt 4 {}
              void uart_send(uint8_t dat) {}
              void uart_uint8_t(uint8_t dat) {}
              void uart_uint16(uint16_t dat) {}
              void uart_sentEnter(void) {}
              void uart_sendstr(const uint8_t *str){}
              uint8_t uart_recv(void) 
              {
                retuen NOT_SUPPORTED;
              }
              uint8_t uarthasdata(void) 
              {
                retuen NOT_SUPPORTED;
              }
                
              #endif   //UART_EABLE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    250    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
